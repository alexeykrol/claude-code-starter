# Концепция расширения фреймворка до мульти-агентной модели (Claude Code + Codex)

Дата: 2026-02-10  
Статус: Концептуальный документ для реализации

## 1. Контекст

Текущая версия фреймворка изначально ориентирована на Claude Code и использует его специфические механизмы (команды, workflows, интеграции, runtime-особенности).  
При этом центральная ценность фреймворка не в конкретном агенте, а в:

- управляемом cold start;
- сохранении проектной памяти между сессиями;
- стандартизированном completion flow;
- безопасной обработке диалогов;
- управляемой миграции и автообновлениях.

Ключевая идея обсуждения: сделать фреймворк пригодным для работы с несколькими кодовыми агентами, где каждый агент использует свой адаптер, но работает поверх общего ядра и общего состояния проекта.

## 2. Проблема, которую нужно решить

Если оставить реализацию только под Claude Code:

- другой агент (например, Codex) не может нативно использовать Claude-специфичные команды/хуки/субагенты;
- при попытке «копировать как есть» возникает несовместимость runtime и командных контрактов;
- возрастает риск дублирования бизнес-логики, расхождения поведения и ошибок в поддержке.

Задача: выделить переносимую бизнес-логику в общее ядро и реализовать агент-специфичные адаптеры отдельно.

## 3. Цель

Сделать фреймворк дву- (и далее multi-) агентным:

- Claude Code работает через свой слой (`CLAUDE.md` + `.claude/`);
- Codex работает через свой слой (`AGENTS.md` + `.codex/`);
- оба агента используют единый контракт состояния и единые протоколы жизненного цикла;
- поддерживаются существующие сценарии миграции, cold start, completion и auto-update.

## 4. Архитектурный принцип

Модель: **Core + Agent Adapters**

### 4.1 Core (агент-агностичный слой)

Core содержит:

- контракты файлов состояния (`SNAPSHOT`, `BACKLOG`, `ARCHITECTURE`, сопутствующие метафайлы);
- переносимую бизнес-логику start/completion;
- миграцию и bootstrap-логику (new / legacy / upgrade / current);
- version-check и update orchestration;
- общие проверки безопасности и правила обработки артефактов.

Core не должен зависеть от конкретного кодового агента.

### 4.2 Adapter (агент-специфичный слой)

Каждый агент получает свой адаптер:

- файл входных инструкций (entry orchestrator);
- специфичные команды, skills, hooks, subagents;
- трансляцию агентных команд в вызовы Core.

Адаптер не дублирует бизнес-логику ядра, а вызывает Core-команды/скрипты.

## 5. Целевая структура хост-проекта

Ниже логическая структура (пример):

```text
<host-project>/
  CLAUDE.md                 # адаптер Claude Code
  AGENTS.md                 # адаптер Codex

  .claude/                  # Claude-специфичный runtime layer
    ...

  .codex/                   # Codex-специфичный runtime layer
    skills/
    subagents/
    hooks/
    commands/
    config/

  .framework/               # опциональный общий служебный слой
    contracts/
    manifests/
    locks/
    state/

  .claude/SNAPSHOT.md       # общий state contract (может оставаться на текущем месте)
  .claude/BACKLOG.md
  .claude/ARCHITECTURE.md
```

Примечание: фактическое физическое расположение state-файлов можно оставить текущим для обратной совместимости. Главное — сделать их агент-агностичным контрактом.

## 6. Две большие функциональные части фреймворка

### 6.1 Часть A: Миграция и внедрение (Bootstrap Lifecycle)

Включает:

- определение сценария проекта (new/legacy/upgrade/current);
- подготовку структуры фреймворка в хост-проекте;
- генерацию/инициализацию meta-файлов;
- проверку текущей версии и условий обновления;
- безопасное применение обновлений.

### 6.2 Часть B: Операционная работа с памятью (Runtime Lifecycle)

Включает:

- cold start;
- загрузку только релевантного контекста;
- completion-процедуры (экспорт, фиксация состояния, проверки);
- управление историей диалогов и приватностью;
- security-проверки и очистку чувствительных данных.

Обе части должны быть доступны как Claude-адаптеру, так и Codex-адаптеру.

## 7. Что именно нужно портировать для Codex

Портировать нужно не «текст команд», а **семантику команд**.

### 7.1 Обязательный набор эквивалентности

Нужно обеспечить эквивалентные по результату сценарии:

- `start` (или эквивалент Codex entry-point);
- `finish` / `/fi` эквивалент;
- экспорт/синхронизацию диалогов;
- security cleanup chain;
- version check и update path;
- миграцию на первом запуске.

### 7.2 Портирование subagents/skills/hooks

Нужно выполнить:

- инвентаризацию существующих Claude-команд/skills/subagents/hooks;
- выделение business logic и side effects для каждой команды;
- реализацию Codex-эквивалентов в `.codex/`;
- валидацию parity по результатам.

Принцип: **разная реализация вызова, одинаковый ожидаемый outcome**.

## 8. Контракт совместимости между агентами

Чтобы несколько агентов могли безопасно работать с одним фреймворком:

- единый источник правды для состояния (SSOT);
- одинаковые правила изменения state-файлов;
- запрет на хранение бизнес-состояния в агент-специфичных директориях;
- единые форматы результатов core-команд;
- общий lock/ownership механизм на сессию (избежать одновременной записи двумя агентами);
- строгая обратная совместимость структуры state-файлов при обновлениях.

## 9. Предлагаемая последовательность реализации

### 9.0 Подтвержденная стратегия внедрения (без риска для Claude-контура)

Этот план зафиксирован как обязательный порядок работ:

1. Сначала создается **полностью параллельная и независимая** структура для Codex.
2. Новый Codex-контур проходит отдельное тестирование и отладку до рабочего состояния.
3. Текущий рабочий контур Claude Code в этот период **не изменяется**.
4. Только после достижения стабильной parity между контурами выполняется оптимизация и выделение общего Core.

Практические ограничения на этапе параллельного внедрения:

- На старте разрешены только **additive changes**: добавление новых файлов/папок под Codex.
- Запрещены изменения, удаление и переименование текущих рабочих компонентов Claude:
  - `CLAUDE.md`
  - `.claude/`
  - существующие Claude-specific команды/хуки/скрипты
- Любая оптимизация общей архитектуры выполняется **после** подтвержденной работоспособности Codex-адаптера.

Почему это важно:

- минимизирует риск регресса в уже работающем процессе;
- упрощает диагностику (ошибки локализуются в новом контуре);
- дает возможность проверять parity по артефактам до рефакторинга.

### 9.0.1 Go/No-Go критерии перехода к оптимизации Core

Переход к оптимизации общего Core разрешен только при выполнении всех условий `Go`.

#### Go (обязательно все пункты)

1. Codex-контур полностью запускается независимо от Claude-контура (`AGENTS.md` + `.codex/`), без изменений `CLAUDE.md` и `.claude/`.
2. Пройдены базовые lifecycle-сценарии в Codex-режиме:
   - cold start;
   - completion;
   - migration/bootstrap;
   - version-check/update;
   - security cleanup chain.
3. Подтверждена parity по артефактам для ключевых сценариев (state-файлы, отчеты, ожидаемые side effects).
4. Нет регрессий в Claude-контуре по smoke-проверкам тех же сценариев.
5. Нет критических/блокирующих дефектов уровня P0/P1 в Codex-контуре.
6. Зафиксирована карта соответствия `Claude feature -> Core -> Codex adapter` и список известных ограничений.

#### No-Go (любой пункт блокирует переход)

1. Любой lifecycle-сценарий в Codex-контуре работает нестабильно или не завершает протокол.
2. Есть расхождения по обязательным артефактам между Claude и Codex без задокументированного и принятого исключения.
3. Обнаружена регрессия в текущем Claude-контуре после добавления Codex-структуры.
4. Не закрыты дефекты безопасности, влияющие на корректность security-chain.
5. Нет формально зафиксированного acceptance-отчета по parity.

#### Артефакт решения о переходе

Перед началом оптимизации создается короткий протокол решения (Go/No-Go) с:

- датой;
- списком проверенных сценариев;
- статусом каждого критерия;
- ответственным решением о переходе.

### Phase 0. Декомпозиция и фиксация контракта

- Зафиксировать перечень всех существующих сценариев start/finish/migration/update/security.
- Сформировать карту `Claude feature -> Core function -> Codex adapter`.
- Определить acceptance criteria на parity.

### Phase 1. Нормализация Core

- Отделить агент-агностичную бизнес-логику от Claude-specific wrappers.
- Ввести формальные интерфейсы входов/выходов для core-команд.
- Централизовать version-check/update orchestration.

### Phase 2. Codex Adapter (первичный)

- Создать `AGENTS.md` как entry orchestration для Codex.
- Создать `.codex/` структуру:
  - `skills/`
  - `subagents/`
  - `commands/`
  - `hooks/`
  - `config/`
- Реализовать маршрутизацию Codex-команд в Core.

### Phase 3. Портирование workflows

- Поочередно перенести:
  - cold start flow;
  - completion flow;
  - migration/bootstrap;
  - version update flow;
  - security chain.

### Phase 4. Совместимость и тесты

- Прогнать сценарии в двух режимах: Claude-adapter и Codex-adapter.
- Проверить одинаковость конечных артефактов (state, отчеты, изменения).
- Проверить устойчивость к повторным запускам и частичным сбоям.

### Phase 5. Документация и эксплуатация

- Обновить docs по dual-agent режиму.
- Добавить таблицу соответствия команд и known limitations.
- Подготовить release notes для перехода на multi-agent версию.

## 10. Что это даст

### 10.1 Практический эффект

- Возможность работать в одном хост-проекте разными агентами без смены базового процесса.
- Снижение vendor/runtime lock-in на одного агента.
- Единая память проекта и единая методология независимо от выбранного инструмента.
- Проще масштабировать и подключать новые агентные адаптеры в будущем.

### 10.2 Инженерный эффект

- Меньше дублирования логики.
- Прозрачнее поддержка и релизы.
- Проще локализовывать баги: core или конкретный adapter.

## 11. Риски и как их закрывать

- Риск расхождения поведения адаптеров.  
  Митигировать parity-тестами по артефактам и контрактам.

- Риск конкурентной записи state двумя агентами.  
  Митигировать lock-файлом/lease-механизмом на время активной сессии.

- Риск дрейфа версий и update-веток.  
  Митигировать единым version manifest и единым update orchestrator.

- Риск неэквивалентности security-chain.  
  Митигировать общим core-пайплайном и адаптерными обвязками без изменения security business logic.

## 12. Критерии готовности (Definition of Done)

Решение считается завершенным, когда:

- хост-проект можно запускать через Claude-adapter и Codex-adapter;
- оба пути выполняют одинаковые ключевые lifecycle-сценарии;
- migration/update работают в обоих режимах;
- state-файлы совместимы и не ломают обратную совместимость;
- документация описывает dual-agent эксплуатацию;
- известные ограничения явно зафиксированы.

## 13. Принцип расширения на других агентов

После Claude и Codex новый агент подключается как еще один adapter при сохранении Core:

- новый entry markdown (оркестратор);
- новая service-директория агента;
- маппинг агентных команд на существующий Core;
- прохождение тех же parity и acceptance тестов.

Это превращает фреймворк из single-agent решения в платформу мульти-агентной разработки.

## 14. Краткое резюме

Портирование возможно и технически обосновано.  
Ключ к успеху: не копировать команды между агентами, а стандартизировать ядро и делать тонкие агентные адаптеры поверх него.

Итоговая архитектура позволит работать в одном проекте через Claude Code и Codex, сохраняя единый процесс, единое состояние и единый жизненный цикл фреймворка.
